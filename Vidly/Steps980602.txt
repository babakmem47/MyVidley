- Create this textbox!

- Create a class: R-click on Model folder - > Add  ->  Class...  ->  Movie.cs     
		public class Movie
			{
				public int Id { get; set; }
				public string Name { get; set; }
			}
		}

- Create a Controller: R-click on Controller folder - > Add  ->  Controller...  ->  MVC 5 Controller - Empty  - > name it: MoviesController
	namespace Vidly.Controllers
	{
		public class MoviesController : Controller
		{
			// GET: Movies
			public ActionResult Index()
			{
				return View();
			}
		}
	}

- change the Index action name to 'Random' and create obj to send to View
		// GET: Movies/Random
		public ActionResult Random()
		{
			var movie = new Movie() { Name = "Matrix" };
			return View(movie);
		}

- Create a view: Random.cshtml:  Alt + Enter on Random name or R-click on /View/Movies -> New View
		@model Vidly.Models.Movie
		@{
			ViewBag.Title = "Random";
			Layout = "~/Views/Shared/_Layout.cshtml";
		}

		<h2>@Model.Name</h2>

//// CHANGE A THEME ///// 
- go to www.bootswatch.com -> https://bootswatch.com/3/  -> download Lumen bootstrap -> rename it to bootstrap-lumen.css 
-> save it to Content folder -> R-click on Content -> Add -> Existing item...  -> select bootstrap-lumen.css

	Change a reference(replace original bootstrap.css with bootstrap-lumen.css)
- in BundleConfig.cs: rename bootstrap.css in "~/Content/bootstrap.css" with bootstrap-lumen.css
		bundles.Add(new StyleBundle("~/Content/css").Include(
							  "~/Content/bootstrap-lumen.css",
							  "~/Content/site.css"));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// 02 ASP.NET MVC Fundamentals /////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// 10. Action Result /////
- our action in controller return 'ActionResult' which is a base class and have many sub types like: 
  ViewResult, PartialViewResult, ContentResult, RedirectResult, JsonResult, FileResult, HttpNotFoundResult, EmptyResult.

- return View(...) :  View method allow us to quickly create a view result. alternatively we can use this:
		return new ViewResult();   === return View(movie);
  but the first approach is most common among developers

  we also use others like:
	return HttpContext("Hello World");	=> return "Hello World" on the page
	return HttpNotFound();				=> return 404 page error result

  we can redirect the user from one page to another:
	return RedirectToAction("Index", "Home", new {page = 1, sortBy = "name"});

  the 3th argument: passing argument to the target action

		result: in URL: http://localhost:28363/?page=1&sortBy=name => means we redirected to the home page



- We could set the return type to 'ViewResult'. This is actually a good practice for UnitTesting
	public ViewResult Random()
  
  but ActionResult is more general and include more sub types


//// 11. Action Parameters /////
Action Result: the output of out actions
Action Parameters: the input of out actions   MVC map any requests to parameters value for action request

	Reuest  ==>  MVC FrameWork  ==>  Action

Parameter values can be embedded in:
	- In the URL:							/movies/edit/1
	- In the query string:					/movies/edit?id=1
	- In the data posted using the form:	id =1

Test this:
- Create an Edit action:
		public ActionResult Edit(int id)
		{
			return Content("id= " + id);
		}
run -> enter /movies/edit/1 and /movies/edit?id=1 in the URL -> the page show id = 1

but if replace id with movieId in our Action it dosn't work!

		public ActionResult Edit(int movieId)
		{
			return Content("movieId= " + movieId);
		}

Unless we change URL to this : /movies/edit?movieId=1

this is because of this line in RouteConfig: 
				url: "{controller}/{action}/{id}",


- We can also use optional parameter:
		public ActionResult Index(int? pageindex, string sortBy)
		{
			if (!pageindex.HasValue)
				pageindex = 1;

			if (String.IsNullOrWhiteSpace(sortBy))
				sortBy = "Name";

			return Content(String.Format("pageIndex = {0} & sortBy = {1}", pageindex, sortBy));
		}
	the build the project and set url to  http://localhost:..../movies

	We can overwrite this parameter:
										http://localhost:..../movies?pageIndex=2
										http://localhost:..../movies?pageIndex=2&sortBy=releaseDate


///// 12. Convention-based Routing /////
The default route in RouteConfig.cs works for most scenarios
But the are situations where we need a route with multiple parameters
		for example we need a route like this:  /movies/released/2015/04   --> to get movies with released year and month

How to create a custom route for the above need:
- RouteConfig: create a route before default route because the order of these route matters
- We need to define routes from the more specific to the most generic

		routes.MapRoute(
			name: "MoviesByReleaseDate",
			url: "movies/released/{year}/{month}",									// be careful: not start url with '/'
			defaults: new { controller = "Movies", action = "ByReleaseDate"}
		);

- Now we need to define the ByReleaseDate action in MoviesController:

		public ActionResult ByReleaseDate(int year, int month)
		{
			return Content(year + " / " + month);
		}

- in the Browser, set the url:
		http://localhost:..../movies/released			--> Error: because url has not match any of our route pattern

		http://localhost:..../movies/released/2015/4    --> OK

- We can also add constrains to out routes. 
  For example we want to enforce the year and month parameters to be 4 and 2 digits respectively
  So we add another argument to our custom route and use Regular Expression:

		   constraints: new { year = @"\d{4}", month = @"\d{2}"}

- So the ultimate version of our custom route look like below:

			routes.MapRoute(
				name: "MoviesByReleaseDate",
				url: "movies/released/{year}/{month}",
				defaults: new { controller = "Movies", action = "ByReleaseDate"},
				constraints: new { year = @"\d{4}", month = @"\d{2}"}
			);

- Now in the Browser, if we refresh we got 404 error:
		http://localhost:..../movies/released/2015/4			--> 404 Error: because of our constrain

  But if we add a zero, we can see the result
		http://localhost:..../movies/released/2015/04			--> OK

- We can also constrain a year to 2015 and 2016(limit the route parameters to few specific values):
		
			constraints: new { year = @"2015|2016", month = @"\d{2}"}

///// 13. Attribute Routing /////
The above method(Convention-based Routing) has 3 fault:
	1. in the future, when the number of route inrease, RouteConfig.cs growth with a lot of custom route and becomes a mess!
	2. We have to go back and forth between our actions and our custom routes
	3. the magic string in our custom route for the name of our action in the controller: if we change the name, it 
	has to be change manually!

- in MVC5, Microsoft introduce a cleaner and better way to create custom route:
- We can apply custom route using an attribute for our action

1. In order to use Attribute Routing, we need to enable it first
		
		Routeconfig.cs -> routes.MapMvcAttributeRoutes();

2. Delete previous(Convention-based) route. Save RouteConfig.cs and close it!

3. Back to our controller -> apply below attribute to the top of our action:

	[Route("movies/released/{year}/{month}")]

4. To apply our constrain, use ':'		constrain:the length of month has to be 2 number

	[Route("movies/released/{year}/{month:regex(\\d{2})}")]				regex is like a function     use two \\ 

5. We can also apply other types of constrains. For example we can apply a second constrain to month and force this
to be a number between 1 and 12:

	[Route("movies/released/{year}/{month:regex(\\d{2}):range(1, 12)}")]

We also have other constrains: min, max, minlength, maxlength, int, float, guid, ...
If you need, google MVC Attribute Route Constrains

///// 14. Passing Data to Views /////
There are 3 ways to do this:
	1. passing data(object) as an argument to the View() method:
		
		public ActionResult Random()
		{
			var movie = new Movie() { Name = "Matrix" };
			return View(movie);
		}

	This is the best way. Just use this in the future.

	Where does movie object go in the ViewResult? 
	If we define an instance of ViewResult, the movie object assign to 'Model' property(below)

			var viewResult = new ViewResult();
			viewResult.ViewData.Model  -> our movie obj assign to this property

	And the View() method will take care of that and we dont have to write all this extra code.

	ViewData: is not a regular dictionary. It is a ViewDataDictionary
	So we can either 
		use it as a dictionary with KeyValue pairs 
		or use its Model property to work with an object(preffered way)
	
	
	2. use ViewData dictionary:

		public ActionResult Random()
		{
			var movie = new Movie() { Name = "Matrix" };

			ViewData["Movie"] = movie;
			return View();
		}

		Then go to View -> instead of using @Model.Name, we need to use @ViewData["Movie"]

		But we can't access the name property of our movie because each item of our dictionary is of type object. 
				
				@ViewData["Movie"].  <--- nothing show after .

		So we need to explicitly cast it to movie. The code is ugly:

				@(  ((Movie)ViewData["Movie"]).Name )

		Another problem is the magic string "Movie": if we change it we need to go to View and change it manually.
		So this way of passing data to the View is fragile


	3. use ViewBag : is a dynamic type
		Microsoft decide to improve ViewData in the very poor way
			
		public ActionResult Random()
		{
			var movie = new Movie() { Name = "Matrix" };

			ViewBag.Movie = movie;
			return View();	
		}

		this 'Movie' property added to the ViewBag at runtime   => means we dont get compile time safety.
		Also it is a magic property, if we change it, we have to remember to change it in the View.
		And we have casting issue as well

